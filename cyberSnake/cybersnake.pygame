# -*- coding: utf-8 -*-
import sys
import os
import logging
import traceback

# --- Configuration du Logging (Early Setup) ---
# Configuré avant les autres imports pour capturer les erreurs de chargement de modules
try:
    # Essaye de déterminer le chemin de base du jeu
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        base_path_log = sys._MEIPASS
    else:
        base_path_log = os.path.dirname(os.path.abspath(__file__))

    log_filename = 'cybersnake_debug.log'
    log_filepath = os.path.join(base_path_log, log_filename)

    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
        filename=log_filepath,
        filemode='w'
    )
    logging.info("--- Initialisation du Logging pour CyberSnake (Early) ---")
except Exception as log_setup_error:
    print(f"ERREUR CRITIQUE: Impossible de configurer le logging: {log_setup_error}")

# --- Import de Pygame avec gestion d'erreur ---
try:
    import pygame
    logging.info("Module pygame importé avec succès.")
except ImportError as e:
    logging.critical("FATAL: Impossible d'importer le module 'pygame'. Est-il installé ?", exc_info=True)
    print("FATAL: Impossible d'importer le module 'pygame'. Vérifiez les logs.")
    sys.exit(1)

# --- Import des modules personnalisés ---
try:
    import config
    import utils
    import game_objects
    import game_states
    logging.info("Modules personnalisés importés avec succès.")
except ImportError as e:
    logging.critical(f"FATAL: Erreur lors de l'import des modules du jeu: {e}", exc_info=True)
    print(f"FATAL: Erreur import modules jeu: {e}")
    sys.exit(1)


def main():
    """Fonction principale du jeu."""
    # --- Initialisation Pygame ---
    try:
        pygame.mixer.pre_init(44100, -16, 2, 512)
        pygame.init()
        pygame.font.init()
        pygame.mixer.init()
        logging.info("Pygame initialisé.") # Log info

    except pygame.error as e:
        logging.critical(f"FATAL: Erreur initialisation Pygame: {e}", exc_info=True) # Log critical
        print(f"FATAL: Erreur initialisation Pygame: {e}") # Garder print pour visibilité si log échoue
        sys.exit(1)

    # --- Initialisation Joysticks ---
    pygame.joystick.init()
    joystick_p1 = None
    joystick_p1_name = "Aucun joystick P1 détecté"
    num_buttons_p1 = 0
    joystick_p2 = None
    joystick_p2_name = "Aucun joystick P2 détecté"
    num_buttons_p2 = 0

    joystick_count = pygame.joystick.get_count()
    logging.info(f"Nombre de joysticks détectés: {joystick_count}")

    if joystick_count > 0:
        try:
            joystick_p1 = pygame.joystick.Joystick(0)
            joystick_p1.init()
            joystick_p1_name = joystick_p1.get_name()
            num_buttons_p1 = joystick_p1.get_numbuttons()
            logging.info(f"Joystick 1 (ID 0) initialisé: {joystick_p1_name} ({num_buttons_p1} boutons)")
        except pygame.error as joy_err:
            logging.error(f"Erreur initialisation joystick 1 (ID 0): {joy_err}", exc_info=True)
            joystick_p1 = None
    else:
        logging.warning("Aucun joystick trouvé pour Joueur 1.")

    if joystick_count > 1:
        try:
            joystick_p2 = pygame.joystick.Joystick(1)
            joystick_p2.init()
            joystick_p2_name = joystick_p2.get_name()
            num_buttons_p2 = joystick_p2.get_numbuttons()
            logging.info(f"Joystick 2 (ID 1) initialisé: {joystick_p2_name} ({num_buttons_p2} boutons)")
        except pygame.error as joy_err:
            logging.error(f"Erreur initialisation joystick 2 (ID 1): {joy_err}", exc_info=True)
            joystick_p2 = None
    elif joystick_count == 1:
        logging.warning("Un seul joystick détecté. Joueur 2 ne sera pas contrôlé par joystick.")
    else:
        logging.warning("Aucun joystick trouvé pour Joueur 2.")
    # --- Fin Initialisation Joysticks ---

    # --- Détection Taille Écran & Calcul Grille Dynamique ---
    detected_width, detected_height = 800, 600
    try:
        display_info = pygame.display.Info()
        detected_width = display_info.current_w
        detected_height = display_info.current_h
        logging.info(f"Taille écran détectée: {detected_width}x{detected_height}")

        TARGET_GRID_W = 40
        TARGET_GRID_H = 30
        grid_size_w = detected_width // TARGET_GRID_W
        grid_size_h = detected_height // TARGET_GRID_H
        calculated_grid_size = max(1, min(grid_size_w, grid_size_h))
        adjusted_width = (detected_width // calculated_grid_size) * calculated_grid_size
        adjusted_height = (detected_height // calculated_grid_size) * calculated_grid_size

        config.GRID_SIZE = calculated_grid_size
        config.SCREEN_WIDTH = adjusted_width
        config.SCREEN_HEIGHT = adjusted_height
        config.GRID_WIDTH = adjusted_width // calculated_grid_size
        config.GRID_HEIGHT = adjusted_height // calculated_grid_size

        logging.info(f"Calculated GRID_SIZE: {config.GRID_SIZE}px")
        logging.info(f"Adjusted Screen Size: {config.SCREEN_WIDTH}x{config.SCREEN_HEIGHT}")
        logging.info(f"Final Grid Dimensions: {config.GRID_WIDTH}x{config.GRID_HEIGHT}")

    except Exception as e:
        logging.warning(f"Attention: Erreur détection/calcul taille écran/grille: {e}. Utilisation défauts.", exc_info=True)
        # Fallback aux valeurs de config.py si la détection échoue
        config.GRID_WIDTH = config.SCREEN_WIDTH // config.GRID_SIZE
        config.GRID_HEIGHT = config.SCREEN_HEIGHT // config.GRID_SIZE
        calculated_grid_size = config.GRID_SIZE
    # --- Fin Détection Taille Écran ---

    # --- Calcul du Chemin de Base pour Assets ---
    base_path_assets = ""
    try:
        if getattr(sys, "frozen", False) and hasattr(sys, '_MEIPASS'):
            base_path_assets = sys._MEIPASS
            logging.info(f"Mode Bundled détecté. Base path assets: {base_path_assets}")
        else:
            base_path_assets = os.path.dirname(os.path.abspath(__file__))
            logging.info(f"Mode Script détecté. Base path assets: {base_path_assets}")
    except Exception as e:
        logging.warning(f"Attention: Impossible de déterminer base_path assets: {e}", exc_info=True)
        base_path_assets = os.getcwd()
    # --- Fin Calcul Chemin de Base ---

    # --- Configuration Fenêtre & Horloge ---
    try:
        screen = pygame.display.set_mode((config.SCREEN_WIDTH, config.SCREEN_HEIGHT))
        pygame.display.set_caption("Cyber Snake Duel - Fusion") # Titre simplifié
        clock = pygame.time.Clock()
        logging.info("Fenêtre et horloge créées.")
    except pygame.error as e:
        logging.critical(f"FATAL: Erreur création fenêtre/horloge: {e}", exc_info=True)
        pygame.quit()
        sys.exit(1)

    # --- Chargement des Polices ---
    fonts = {}
    try:
        fonts['small'] = pygame.font.SysFont("Consolas", 18)
        fonts['default'] = pygame.font.SysFont("Consolas", 24)
        fonts['medium'] = pygame.font.SysFont("Consolas", 36)
        fonts['large'] = pygame.font.SysFont("Consolas", 72)
        fonts['title'] = pygame.font.SysFont("Consolas", 90)
        logging.info("Police Consolas chargée.")
    except pygame.error:
        logging.warning("Erreur SysFont Consolas. Utilisation police défaut.", exc_info=False) # Log léger
        try:
            fonts['small'] = pygame.font.Font(None, 22)
            fonts['default'] = pygame.font.Font(None, 30)
            fonts['medium'] = pygame.font.Font(None, 40)
            fonts['large'] = pygame.font.Font(None, 72)
            fonts['title'] = pygame.font.Font(None, 100)
            logging.info("Police défaut chargée.")
        except Exception as font_e:
            logging.critical(f"FATAL: Erreur chargement police défaut: {font_e}", exc_info=True)
            pygame.quit()
            sys.exit(1)
    # --- Fin Chargement Polices ---

    # --- Chargement Assets & High Scores ---
    try:
        menu_background_image = utils.load_assets(base_path_assets)
        utils.load_high_scores(base_path_assets)
        logging.info(f"Assets et High Scores chargés. Scores: Solo={len(utils.high_scores.get('solo', []))}, VsAI={len(utils.high_scores.get('vs_ai', []))}, PvP={len(utils.high_scores.get('pvp', []))}, Survie={len(utils.high_scores.get('survie', []))}")
    except Exception as asset_err:
        logging.error(f"Erreur chargement assets/high scores: {asset_err}", exc_info=True)
        menu_background_image = None # Fallback
    # --- Fin Chargement Assets ---

    # --- Initialisation de l'État du Jeu ---
    game_state = {
        'current_state': config.MENU,
        'current_game_mode': config.MODE_VS_AI, # Mode par défaut
        'player_snake': None, 'player2_snake': None, 'enemy_snake': None,
        'foods': [], 'mines': [], 'powerups': [],
        'player_projectiles': [], 'player2_projectiles': [], 'enemy_projectiles': [],
        'nests': [], 'moving_mines': [], 'active_enemies': [],
        'current_map_walls': [],
        'selected_map_key': config.DEFAULT_MAP_KEY,
        'map_selection_index': 0, 'menu_selection_index': 0, # Index commence à 0
        'pvp_setup_index': 0, 'hall_of_fame_index': 0,
        'player1_name_input': "Joueur 1", 'player2_name_input': "Joueur 2",
        'pvp_name_entry_stage': 1,
        'pvp_condition_type': config.PVP_DEFAULT_CONDITION,
        'pvp_target_time': config.PVP_DEFAULT_TIME_SECONDS,
        'pvp_target_kills': config.PVP_DEFAULT_KILLS,
        'pvp_start_armor': config.pvp_start_armor,
        'pvp_start_ammo': config.pvp_start_ammo,
        'last_mine_spawn_time': 0, 'last_powerup_spawn_time': 0, 'last_food_spawn_time': 0,
        'last_mine_wave_spawn_time': 0, 'last_nest_spawn_time': 0,
        'pvp_start_time': 0, 'pvp_game_over_reason': None,
        'player1_respawn_timer': 0, 'player2_respawn_timer': 0, # Gardé pour référence, mais la logique a changé
        'p1_death_time': 0, 'p2_death_time': 0, # Nouveaux timers de mort
        'current_objective': None, 'objective_display_text': "", 'objective_complete_timer': 0,
        'survival_wave': 0, 'survival_wave_start_time': 0,
        'current_survival_interval_factor': config.SURVIVAL_INITIAL_INTERVAL_FACTOR,
        'game_over_hs_saved': False,
        'base_path': base_path_assets, # Utilise le chemin assets
        'screen': screen, 'clock': clock,
        'font_small': fonts['small'], 'font_default': fonts['default'],
        'font_medium': fonts['medium'], 'font_large': fonts['large'], 'font_title': fonts['title'],
        'menu_background_image': menu_background_image,
        'joystick_p1': joystick_p1, 'joystick_p1_name': joystick_p1_name, 'num_buttons_p1': num_buttons_p1,
        'joystick_p2': joystick_p2, 'joystick_p2_name': joystick_p2_name, 'num_buttons_p2': num_buttons_p2,
        'calculated_grid_size': calculated_grid_size,
    }

    # Check for update flag
    if os.path.exists("update_success.flag"):
        try:
            game_state['show_version_popup'] = True
            os.remove("update_success.flag")
            logging.info("Update flag detected. Version popup enabled.")
        except Exception as e:
            logging.error(f"Error handling update flag: {e}")

    logging.info("État du jeu initialisé.")
    # --- Fin Initialisation État du Jeu ---

    # --- Mappage des États aux Fonctions ---
    state_functions = {
        config.MENU: game_states.run_menu,
        config.NAME_ENTRY_SOLO: game_states.run_name_entry_solo,
        config.MAP_SELECTION: game_states.run_map_selection,
        config.PVP_SETUP: game_states.run_pvp_setup,
        config.NAME_ENTRY_PVP: game_states.run_name_entry_pvp,
        config.PLAYING: game_states.run_game,
        config.PAUSED: game_states.run_pause,
        config.GAME_OVER: game_states.run_game_over,
        config.HALL_OF_FAME: game_states.run_hall_of_fame,
        config.UPDATE: game_states.run_update,
    }
    # --- Fin Mappage États ---

    # --- Boucle Principale ---
    running = True
    logging.info("Entrée dans la boucle principale du jeu.")
    while running:
        dt = clock.tick(60)
        events = pygame.event.get()
        current_state_key = game_state['current_state']
        run_current_state = state_functions.get(current_state_key)

        if run_current_state:
            try:
                next_state_val = run_current_state(events, dt, screen, game_state)

                if isinstance(next_state_val, bool) and not next_state_val:
                    logging.info("Signal de fin de jeu reçu de l'état actuel.")
                    running = False
                elif isinstance(next_state_val, int) and next_state_val != current_state_key:
                    logging.debug(f"Changement d'état de {current_state_key} vers {next_state_val}")
                    game_state['current_state'] = next_state_val
                # Si next_state_val est un int ET égal à current_state_key, on reste dans le même état.
                # Si next_state_val est None (certaines fonctions pourraient retourner None implicitement),
                # on pourrait considérer cela comme "rester dans l'état actuel" ou logguer une alerte.
                # Pour l'instant, on ne change d'état que si explicitement différent.

            except Exception as e:
                # MODIFIÉ: Log l'erreur complète dans le fichier log
                logging.error(f"--- ERREUR DANS L'ÉTAT {current_state_key} ---", exc_info=True)
                try:
                    pygame.mixer.music.stop()
                except Exception as music_err:
                    logging.warning(f"Erreur mineure arrêt musique lors gestion erreur: {music_err}", exc_info=False)
                game_state['current_state'] = config.MENU # Retour au menu par sécurité
                pygame.time.wait(2000) # Pause pour potentiellement voir l'erreur si console visible
        else:
            # MODIFIÉ: Log l'erreur d'état inconnu
            logging.error(f"État de jeu inconnu ou fonction non trouvée pour clé: {current_state_key}. Retour au menu.")
            game_state['current_state'] = config.MENU

        if running:
            try:
                pygame.display.flip()
            except pygame.error as flip_e:
                logging.critical(f"Erreur fatale pygame.display.flip(): {flip_e}", exc_info=True)
                running = False
    # --- Fin Boucle Principale ---

    logging.info("Sortie de la boucle principale. Nettoyage et fermeture.")
    pygame.quit()
    sys.exit()

# --- Point d'Entrée ---
if __name__ == "__main__":
    try:
        main()
    except SystemExit: # Permet à sys.exit() de fonctionner normalement
        logging.info("Sortie normale du jeu via SystemExit.")
    except Exception as e_outer:
        # Capture les erreurs fatales qui pourraient survenir HORS de la boucle principale
        # (par exemple, pendant l'initialisation avant la boucle ou après sa sortie mais avant sys.exit)
        logging.critical("--- ERREUR FATALE INATTENDUE (HORS BOUCLE PRINCIPALE) ---", exc_info=True)
        # print("\n--- ERREUR FATALE INATTENDUE (HORS BOUCLE PRINCIPALE) ---") # Garder pour visibilité console
        # traceback.print_exc() # Garder pour visibilité console
        # print("------------------------------------------------------\n")
        try:
            pygame.quit() # Tente de fermer Pygame proprement
        except Exception as pq_err:
            logging.error(f"Erreur lors de pygame.quit() pendant la gestion d'erreur fatale: {pq_err}", exc_info=False)
        sys.exit(1) # Quitte avec un code d'erreur

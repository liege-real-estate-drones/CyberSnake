# -*- coding: utf-8 -*-
import sys
import os
import logging
import traceback

# --- Configuration du Logging (Early Setup) ---
# Configuré avant les autres imports pour capturer les erreurs de chargement de modules
try:
    # Essaye de déterminer le chemin de base du jeu
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        base_path_log = sys._MEIPASS
    else:
        base_path_log = os.path.dirname(os.path.abspath(__file__))

    log_filename = 'cybersnake_debug.log'
    log_filepath = os.path.join(base_path_log, log_filename)

    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
        filename=log_filepath,
        filemode='w'
    )
    logging.info("--- Initialisation du Logging pour CyberSnake (Early) ---")
except Exception as log_setup_error:
    print(f"ERREUR CRITIQUE: Impossible de configurer le logging: {log_setup_error}")

# --- Import de Pygame avec gestion d'erreur ---
try:
    import pygame
    logging.info("Module pygame importé avec succès.")
except ImportError as e:
    logging.critical("FATAL: Impossible d'importer le module 'pygame'. Est-il installé ?", exc_info=True)
    print("FATAL: Impossible d'importer le module 'pygame'. Vérifiez les logs.")
    sys.exit(1)

# --- Import des modules personnalisés ---
try:
    import config
    import utils
    import game_objects
    import game_states
    logging.info("Modules personnalisés importés avec succès.")
except ImportError as e:
    logging.critical(f"FATAL: Erreur lors de l'import des modules du jeu: {e}", exc_info=True)
    print(f"FATAL: Erreur import modules jeu: {e}")
    sys.exit(1)


def main():
    """Fonction principale du jeu."""
    # --- Initialisation Pygame ---
    try:
        pygame.mixer.pre_init(44100, -16, 2, 512)
        pygame.init()
        pygame.font.init()
        pygame.mixer.init()
        logging.info("Pygame initialisé.") # Log info

    except pygame.error as e:
        logging.critical(f"FATAL: Erreur initialisation Pygame: {e}", exc_info=True) # Log critical
        print(f"FATAL: Erreur initialisation Pygame: {e}") # Garder print pour visibilité si log échoue
        sys.exit(1)

    # --- Initialisation Joysticks ---
    pygame.joystick.init()
    joystick_p1 = None
    joystick_p1_name = "Aucun joystick P1 détecté"
    num_buttons_p1 = 0
    joystick_p2 = None
    joystick_p2_name = "Aucun joystick P2 détecté"
    num_buttons_p2 = 0

    joystick_count = pygame.joystick.get_count()
    logging.info(f"Nombre de joysticks détectés: {joystick_count}")

    if joystick_count > 0:
        try:
            joystick_p1 = pygame.joystick.Joystick(0)
            joystick_p1.init()
            joystick_p1_name = joystick_p1.get_name()
            num_buttons_p1 = joystick_p1.get_numbuttons()
            logging.info(f"Joystick 1 (ID 0) initialisé: {joystick_p1_name} ({num_buttons_p1} boutons)")
        except pygame.error as joy_err:
            logging.error(f"Erreur initialisation joystick 1 (ID 0): {joy_err}", exc_info=True)
            joystick_p1 = None
    else:
        logging.warning("Aucun joystick trouvé pour Joueur 1.")

    if joystick_count > 1:
        try:
            joystick_p2 = pygame.joystick.Joystick(1)
            joystick_p2.init()
            joystick_p2_name = joystick_p2.get_name()
            num_buttons_p2 = joystick_p2.get_numbuttons()
            logging.info(f"Joystick 2 (ID 1) initialisé: {joystick_p2_name} ({num_buttons_p2} boutons)")
        except pygame.error as joy_err:
            logging.error(f"Erreur initialisation joystick 2 (ID 1): {joy_err}", exc_info=True)
            joystick_p2 = None
    elif joystick_count == 1:
        logging.warning("Un seul joystick détecté. Joueur 2 ne sera pas contrôlé par joystick.")
    else:
        logging.warning("Aucun joystick trouvé pour Joueur 2.")
    # --- Fin Initialisation Joysticks ---

    # --- Calcul du Chemin de Base pour Assets ---
    base_path_assets = ""
    try:
        if getattr(sys, "frozen", False) and hasattr(sys, '_MEIPASS'):
            base_path_assets = sys._MEIPASS
            logging.info(f"Mode Bundled détecté. Base path assets: {base_path_assets}")
        else:
            base_path_assets = os.path.dirname(os.path.abspath(__file__))
            logging.info(f"Mode Script détecté. Base path assets: {base_path_assets}")
    except Exception as e:
        logging.warning(f"Attention: Impossible de déterminer base_path assets: {e}", exc_info=True)
        base_path_assets = os.getcwd()
    # --- Fin Calcul Chemin de Base ---

    # --- Chargement Options (vidéo) ---
    grid_size_override = None
    try:
        opts = utils.load_game_options(base_path_assets)
        config.SHOW_GRID = bool(opts.get("show_grid", getattr(config, "SHOW_GRID", True)))
        config.SNAKE_STYLE = str(opts.get("snake_style", getattr(config, "SNAKE_STYLE", "sprites")))
        p1_style = opts.get("snake_style_p1", None)
        p2_style = opts.get("snake_style_p2", None)
        config.SNAKE_STYLE_P1 = str(p1_style).strip().lower() if p1_style else None
        config.SNAKE_STYLE_P2 = str(p2_style).strip().lower() if p2_style else None

        try:
            p1_col = opts.get("snake_color_p1", getattr(config, "SNAKE_COLOR_PRESET_P1", "cyber"))
            p2_col = opts.get("snake_color_p2", getattr(config, "SNAKE_COLOR_PRESET_P2", "pink"))
            config.apply_snake_color_presets(p1_col, p2_col)
        except Exception:
            pass
        config.CLASSIC_ARENA = str(opts.get("classic_arena", getattr(config, "CLASSIC_ARENA", "full")))

        speed_key = str(opts.get("game_speed", getattr(config, "GAME_SPEED", "normal"))).strip().lower()
        speed_map = {"slow": 1.25, "normal": 1.0, "fast": 0.85}
        config.GAME_SPEED = speed_key if speed_key in speed_map else "normal"
        config.GAME_SPEED_FACTOR = float(speed_map.get(config.GAME_SPEED, 1.0))

        try:
            ai_key = str(opts.get("ai_difficulty", getattr(config, "AI_DIFFICULTY", "normal"))).strip().lower()
        except Exception:
            ai_key = str(getattr(config, "AI_DIFFICULTY", "normal")).strip().lower()
        try:
            presets = getattr(config, "AI_DIFFICULTY_PRESETS", {}) or {}
            if ai_key not in presets:
                ai_key = "normal"
        except Exception:
            ai_key = "normal"
        config.AI_DIFFICULTY = ai_key

        try:
            wall_key = str(opts.get("wall_style", getattr(config, "WALL_STYLE", "panel"))).strip().lower()
        except Exception:
            wall_key = str(getattr(config, "WALL_STYLE", "panel")).strip().lower()
        if wall_key not in ("classic", "panel", "neon", "circuit"):
            wall_key = "panel"
        config.WALL_STYLE = wall_key

        particle_key = str(opts.get("particle_density", getattr(config, "PARTICLE_DENSITY", "normal"))).strip().lower()
        particle_map = {"off": 0.0, "low": 0.5, "normal": 1.0, "high": 1.6}
        config.PARTICLE_DENSITY = particle_key if particle_key in particle_map else "normal"
        config.PARTICLE_FACTOR = float(particle_map.get(config.PARTICLE_DENSITY, 1.0))

        config.SCREEN_SHAKE_ENABLED = bool(opts.get("screen_shake", getattr(config, "SCREEN_SHAKE_ENABLED", True)))
        config.SHOW_FPS = bool(opts.get("show_fps", getattr(config, "SHOW_FPS", False)))

        ui_scale_key = str(opts.get("ui_scale", getattr(config, "UI_SCALE", "normal"))).strip().lower()
        ui_scale_map = {"small": 0.9, "normal": 1.0, "large": 1.15}
        if ui_scale_key not in ui_scale_map:
            ui_scale_key = "normal"
        config.UI_SCALE = ui_scale_key
        config.UI_SCALE_FACTOR = float(ui_scale_map.get(ui_scale_key, 1.0))

        hud_mode_key = str(opts.get("hud_mode", getattr(config, "HUD_MODE", "normal"))).strip().lower()
        if hud_mode_key not in ("normal", "minimal"):
            hud_mode_key = "normal"
        config.HUD_MODE = hud_mode_key

        # Contrôles (joystick) via controls.json
        try:
            controls_cfg = utils.load_controls(base_path_assets)
            utils.apply_controls_to_config(controls_cfg)
        except Exception as e:
            logging.warning(f"Attention: Impossible de charger controls.json: {e}", exc_info=True)

        try:
            utils.set_music_volume(opts.get("music_volume", utils.music_volume))
            utils.set_sound_volume(opts.get("sound_volume", utils.sound_volume))
        except Exception:
            pass
        grid_size_override = opts.get("grid_size", None)
    except Exception as e:
        logging.warning(f"Attention: Impossible de charger {config.GAME_OPTIONS_FILE}: {e}", exc_info=True)
    # --- Fin Chargement Options ---

    # --- Détection Taille Écran & Calcul Grille Dynamique ---
    detected_width, detected_height = 800, 600
    try:
        display_info = pygame.display.Info()
        detected_width = display_info.current_w
        detected_height = display_info.current_h
        logging.info(f"Taille écran détectée: {detected_width}x{detected_height}")

        if isinstance(grid_size_override, int) and grid_size_override > 0:
            calculated_grid_size = int(grid_size_override)
        else:
            TARGET_GRID_W = 40
            TARGET_GRID_H = 30
            grid_size_w = detected_width // TARGET_GRID_W
            grid_size_h = detected_height // TARGET_GRID_H
            calculated_grid_size = max(1, min(grid_size_w, grid_size_h))
        adjusted_width = (detected_width // calculated_grid_size) * calculated_grid_size
        adjusted_height = (detected_height // calculated_grid_size) * calculated_grid_size

        config.GRID_SIZE = calculated_grid_size
        config.SCREEN_WIDTH = adjusted_width
        config.SCREEN_HEIGHT = adjusted_height
        config.GRID_WIDTH = adjusted_width // calculated_grid_size
        config.GRID_HEIGHT = adjusted_height // calculated_grid_size

        logging.info(f"Calculated GRID_SIZE: {config.GRID_SIZE}px")
        logging.info(f"Adjusted Screen Size: {config.SCREEN_WIDTH}x{config.SCREEN_HEIGHT}")
        logging.info(f"Final Grid Dimensions: {config.GRID_WIDTH}x{config.GRID_HEIGHT}")

    except Exception as e:
        logging.warning(f"Attention: Erreur détection/calcul taille écran/grille: {e}. Utilisation défauts.", exc_info=True)
        # Fallback aux valeurs de config.py si la détection échoue
        config.GRID_WIDTH = config.SCREEN_WIDTH // config.GRID_SIZE
        config.GRID_HEIGHT = config.SCREEN_HEIGHT // config.GRID_SIZE
        calculated_grid_size = config.GRID_SIZE
    # --- Fin Détection Taille Écran ---

    # --- Configuration Fenêtre & Horloge ---
    try:
        screen = pygame.display.set_mode((config.SCREEN_WIDTH, config.SCREEN_HEIGHT))
        pygame.display.set_caption("Cyber Snake Duel - Fusion") # Titre simplifié
        clock = pygame.time.Clock()
        logging.info("Fenêtre et horloge créées.")
    except pygame.error as e:
        logging.critical(f"FATAL: Erreur création fenêtre/horloge: {e}", exc_info=True)
        pygame.quit()
        sys.exit(1)

    # --- Chargement des Polices ---
    fonts = {}
    try:
        ui_scale_factor = float(getattr(config, "UI_SCALE_FACTOR", 1.0))
    except Exception:
        ui_scale_factor = 1.0

    def _scaled_font_size(base_size):
        return max(12, int(round(float(base_size) * ui_scale_factor)))

    try:
        fonts['small'] = pygame.font.SysFont("Consolas", _scaled_font_size(18))
        fonts['default'] = pygame.font.SysFont("Consolas", _scaled_font_size(24))
        fonts['medium'] = pygame.font.SysFont("Consolas", _scaled_font_size(36))
        fonts['large'] = pygame.font.SysFont("Consolas", _scaled_font_size(72))
        fonts['title'] = pygame.font.SysFont("Consolas", _scaled_font_size(90))
        logging.info("Police Consolas chargée.")
    except pygame.error:
        logging.warning("Erreur SysFont Consolas. Utilisation police défaut.", exc_info=False) # Log léger
        try:
            fonts['small'] = pygame.font.Font(None, _scaled_font_size(22))
            fonts['default'] = pygame.font.Font(None, _scaled_font_size(30))
            fonts['medium'] = pygame.font.Font(None, _scaled_font_size(40))
            fonts['large'] = pygame.font.Font(None, _scaled_font_size(72))
            fonts['title'] = pygame.font.Font(None, _scaled_font_size(100))
            logging.info("Police défaut chargée.")
        except Exception as font_e:
            logging.critical(f"FATAL: Erreur chargement police défaut: {font_e}", exc_info=True)
            pygame.quit()
            sys.exit(1)
    # --- Fin Chargement Polices ---

    # --- Chargement Assets & High Scores ---
    try:
        menu_background_image = utils.load_assets(base_path_assets)
        utils.load_high_scores(base_path_assets)
        logging.info(f"Assets et High Scores chargés. Scores: Solo={len(utils.high_scores.get('solo', []))}, VsAI={len(utils.high_scores.get('vs_ai', []))}, PvP={len(utils.high_scores.get('pvp', []))}, Survie={len(utils.high_scores.get('survie', []))}")
    except Exception as asset_err:
        logging.error(f"Erreur chargement assets/high scores: {asset_err}", exc_info=True)
        menu_background_image = None # Fallback
    # --- Fin Chargement Assets ---

    # --- Initialisation de l'État du Jeu ---
    game_state = {
        'current_state': config.MENU,
        'current_game_mode': config.MODE_VS_AI, # Mode par défaut
        'player_snake': None, 'player2_snake': None, 'enemy_snake': None,
        'foods': [], 'mines': [], 'powerups': [],
        'player_projectiles': [], 'player2_projectiles': [], 'enemy_projectiles': [],
        'nests': [], 'moving_mines': [], 'active_enemies': [],
        'current_map_walls': [],
        'selected_map_key': config.DEFAULT_MAP_KEY,
        'map_selection_index': 0, 'menu_selection_index': 0, # Index commence à 0
        'pvp_setup_index': 0, 'hall_of_fame_index': 0,
        'player1_name_input': "Thi", 'player2_name_input': "Alex",
        'pvp_name_entry_stage': 1,
        'pvp_condition_type': config.PVP_DEFAULT_CONDITION,
        'pvp_target_time': config.PVP_DEFAULT_TIME_SECONDS,
        'pvp_target_kills': config.PVP_DEFAULT_KILLS,
        'pvp_start_armor': config.pvp_start_armor,
        'pvp_start_ammo': config.pvp_start_ammo,
        'last_mine_spawn_time': 0, 'last_powerup_spawn_time': 0, 'last_food_spawn_time': 0,
        'last_mine_wave_spawn_time': 0, 'last_nest_spawn_time': 0,
        'pvp_start_time': 0, 'pvp_game_over_reason': None,
        'player1_respawn_timer': 0, 'player2_respawn_timer': 0, # Gardé pour référence, mais la logique a changé
        'p1_death_time': 0, 'p2_death_time': 0, # Nouveaux timers de mort
        'current_objective': None, 'objective_display_text': "", 'objective_complete_timer': 0,
        'survival_wave': 0, 'survival_wave_start_time': 0,
        'current_survival_interval_factor': config.SURVIVAL_INITIAL_INTERVAL_FACTOR,
        'game_over_hs_saved': False,
        'base_path': base_path_assets, # Utilise le chemin assets
        'screen': screen, 'clock': clock,
        'font_small': fonts['small'], 'font_default': fonts['default'],
        'font_medium': fonts['medium'], 'font_large': fonts['large'], 'font_title': fonts['title'],
        'menu_background_image': menu_background_image,
        'joystick_p1': joystick_p1, 'joystick_p1_name': joystick_p1_name, 'num_buttons_p1': num_buttons_p1,
        'joystick_p2': joystick_p2, 'joystick_p2_name': joystick_p2_name, 'num_buttons_p2': num_buttons_p2,
        'calculated_grid_size': calculated_grid_size,
        # Inactivité (mode démo)
        'last_input_time': pygame.time.get_ticks(),
    }

    # Check for update flag
    if os.path.exists("update_success.flag"):
        try:
            game_state['show_version_popup'] = True
            os.remove("update_success.flag")
            logging.info("Update flag detected. Version popup enabled.")
        except Exception as e:
            logging.error(f"Error handling update flag: {e}")

    logging.info("État du jeu initialisé.")
    # --- Fin Initialisation État du Jeu ---

    # --- Mappage des États aux Fonctions ---
    state_functions = {
        config.MENU: game_states.run_menu,
        config.OPTIONS: game_states.run_options,
        config.CONTROLS: game_states.run_controls_remap,
        config.NAME_ENTRY_SOLO: game_states.run_name_entry_solo,
        config.MAP_SELECTION: game_states.run_map_selection,
        config.VS_AI_SETUP: game_states.run_vs_ai_setup,
        config.CLASSIC_SETUP: game_states.run_classic_setup,
        config.PVP_SETUP: game_states.run_pvp_setup,
        config.NAME_ENTRY_PVP: game_states.run_name_entry_pvp,
        config.PLAYING: game_states.run_game,
        config.PAUSED: game_states.run_pause,
        config.GAME_OVER: game_states.run_game_over,
        config.HALL_OF_FAME: game_states.run_hall_of_fame,
        config.UPDATE: game_states.run_update,
        config.DEMO: game_states.run_demo,
    }
    # --- Fin Mappage États ---

    # --- Boucle Principale ---
    running = True
    logging.info("Entrée dans la boucle principale du jeu.")
    while running:
        dt = clock.tick(60)
        events = pygame.event.get()
        now_ticks = pygame.time.get_ticks()

        # --- Inactivité / Attract (démo) ---
        try:
            last_input_time = int(game_state.get('last_input_time', now_ticks))
        except Exception:
            last_input_time = now_ticks

        def _is_user_input_event(ev):
            try:
                t = ev.type
            except Exception:
                return False
            if t in (pygame.JOYBUTTONDOWN, pygame.JOYHATMOTION, pygame.KEYDOWN):
                return True
            if t == pygame.JOYAXISMOTION:
                try:
                    thr = float(getattr(config, "JOYSTICK_THRESHOLD", 0.6))
                except Exception:
                    thr = 0.6
                try:
                    return abs(float(getattr(ev, "value", 0.0))) > thr
                except Exception:
                    return False
            return False

        if any(_is_user_input_event(ev) for ev in events):
            game_state['last_input_time'] = now_ticks
            last_input_time = now_ticks

        # --- Transitions (fondu) ---
        fade_ms = int(getattr(config, "TRANSITION_FADE_MS", 260))
        fade_ms = max(60, fade_ms)

        def _get_fade_overlay():
            overlay = game_state.get('_transition_fade_overlay')
            try:
                if overlay is None or overlay.get_size() != screen.get_size():
                    overlay = pygame.Surface(screen.get_size())
                    overlay.fill((0, 0, 0))
                    game_state['_transition_fade_overlay'] = overlay
            except Exception:
                overlay = pygame.Surface((config.SCREEN_WIDTH, config.SCREEN_HEIGHT))
                overlay.fill((0, 0, 0))
                game_state['_transition_fade_overlay'] = overlay
            return overlay

        transition_phase = game_state.get('_transition_phase')
        transition_alpha = float(game_state.get('_transition_alpha', 0.0) or 0.0)
        transition_from_surface = game_state.get('_transition_from_surface')

        if transition_phase == 'fade_out' and transition_from_surface is not None:
            try:
                if transition_from_surface.get_size() != screen.get_size():
                    transition_from_surface = pygame.transform.smoothscale(transition_from_surface, screen.get_size())
                screen.blit(transition_from_surface, (0, 0))
            except Exception:
                screen.fill((0, 0, 0))

            transition_alpha = min(255.0, transition_alpha + (255.0 * float(dt) / float(fade_ms)))
            overlay = _get_fade_overlay()
            overlay.set_alpha(int(transition_alpha))
            screen.blit(overlay, (0, 0))
            game_state['_transition_alpha'] = transition_alpha

            if transition_alpha >= 255.0:
                game_state['_transition_phase'] = 'fade_in'
                game_state['_transition_alpha'] = 255.0
                game_state.pop('_transition_from_surface', None)

        elif transition_phase == 'fade_in':
            current_state_key = game_state.get('current_state', config.MENU)
            run_current_state = state_functions.get(current_state_key)
            if run_current_state:
                try:
                    # Pendant le fondu, on ignore les inputs (évite un double-select)
                    run_current_state([], dt, screen, game_state)
                except Exception:
                    logging.error(f"--- ERREUR DANS L'ÉTAT {current_state_key} (fade_in) ---", exc_info=True)
                    game_state['current_state'] = config.MENU
            else:
                logging.error(f"État de jeu inconnu (fade_in): {current_state_key}. Retour au menu.")
                game_state['current_state'] = config.MENU

            # Permet à un état (ex: Options) de recréer la surface écran
            screen = game_state.get('screen', screen)

            overlay = _get_fade_overlay()
            overlay.set_alpha(int(max(0.0, min(255.0, transition_alpha))))
            screen.blit(overlay, (0, 0))

            transition_alpha = max(0.0, transition_alpha - (255.0 * float(dt) / float(fade_ms)))
            game_state['_transition_alpha'] = transition_alpha
            if transition_alpha <= 0.0:
                game_state.pop('_transition_phase', None)
                game_state.pop('_transition_alpha', None)

        else:
            # --- Exécution normale d'un état ---
            current_state_key = game_state.get('current_state', config.MENU)
            run_current_state = state_functions.get(current_state_key)

            if run_current_state:
                try:
                    # Déclenche la démo uniquement hors partie (et hors update/pause)
                    idle_demo_states = {
                        config.MENU,
                        config.OPTIONS,
                        config.HALL_OF_FAME,
                        config.MAP_SELECTION,
                        config.PVP_SETUP,
                        config.CLASSIC_SETUP,
                        config.NAME_ENTRY_SOLO,
                        config.NAME_ENTRY_PVP,
                        config.GAME_OVER,
                    }
                    force_next_state = None
                    if (
                        current_state_key in idle_demo_states
                        and current_state_key != config.DEMO
                        and (now_ticks - last_input_time) >= int(getattr(config, "DEMO_IDLE_TIMEOUT_MS", 180000))
                    ):
                        force_next_state = config.DEMO

                    next_state_val = run_current_state(events, dt, screen, game_state)

                    # Permet à un état (ex: Options) de recréer la surface écran
                    screen = game_state.get('screen', screen)

                    if isinstance(next_state_val, bool) and not next_state_val:
                        logging.info("Signal de fin de jeu reçu de l'état actuel.")
                        running = False
                    else:
                        requested_state = force_next_state if isinstance(force_next_state, int) else next_state_val
                        if isinstance(requested_state, int) and requested_state != current_state_key:
                            logging.debug(f"Changement d'état de {current_state_key} vers {requested_state}")
                            try:
                                game_state['_transition_from_surface'] = screen.copy()
                                game_state['_transition_phase'] = 'fade_out'
                                game_state['_transition_alpha'] = 0.0
                            except Exception:
                                game_state['_transition_phase'] = 'fade_in'
                                game_state['_transition_alpha'] = 255.0
                            game_state['current_state'] = requested_state
                            game_state['last_input_time'] = now_ticks

                except Exception:
                    logging.error(f"--- ERREUR DANS L'ÉTAT {current_state_key} ---", exc_info=True)
                    try:
                        pygame.mixer.music.stop()
                    except Exception as music_err:
                        logging.warning(f"Erreur mineure arrêt musique lors gestion erreur: {music_err}", exc_info=False)
                    game_state['current_state'] = config.MENU # Retour au menu par sécurité
                    pygame.time.wait(2000) # Pause pour potentiellement voir l'erreur si console visible
            else:
                logging.error(f"État de jeu inconnu ou fonction non trouvée pour clé: {current_state_key}. Retour au menu.")
                game_state['current_state'] = config.MENU

        # Permet à un état (ex: Options) de recréer la surface écran
        screen = game_state.get('screen', screen)

        if running:
            try:
                pygame.display.flip()
            except pygame.error as flip_e:
                logging.critical(f"Erreur fatale pygame.display.flip(): {flip_e}", exc_info=True)
                running = False
    # --- Fin Boucle Principale ---

    logging.info("Sortie de la boucle principale. Nettoyage et fermeture.")
    pygame.quit()
    sys.exit()

# --- Point d'Entrée ---
if __name__ == "__main__":
    try:
        main()
    except SystemExit: # Permet à sys.exit() de fonctionner normalement
        logging.info("Sortie normale du jeu via SystemExit.")
    except Exception as e_outer:
        # Capture les erreurs fatales qui pourraient survenir HORS de la boucle principale
        # (par exemple, pendant l'initialisation avant la boucle ou après sa sortie mais avant sys.exit)
        logging.critical("--- ERREUR FATALE INATTENDUE (HORS BOUCLE PRINCIPALE) ---", exc_info=True)
        # print("\n--- ERREUR FATALE INATTENDUE (HORS BOUCLE PRINCIPALE) ---") # Garder pour visibilité console
        # traceback.print_exc() # Garder pour visibilité console
        # print("------------------------------------------------------\n")
        try:
            pygame.quit() # Tente de fermer Pygame proprement
        except Exception as pq_err:
            logging.error(f"Erreur lors de pygame.quit() pendant la gestion d'erreur fatale: {pq_err}", exc_info=False)
        sys.exit(1) # Quitte avec un code d'erreur
